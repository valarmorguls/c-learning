#拷贝构造为什么要传引用
1. 假设 A b = a(实参); A(const A a(形参)) 
实参要给形参进行拷贝，无限次拷贝
#为什么拷贝构造要加const？
A a = 45;
这种类型不能绑定到匿名对象中去
a ------> 拷贝 --------> A (A &a) 无法绑定到对象中去，
1. 兼容匿名对象
2. 逻辑上的常量限制
3. 兼容const类型的拷贝
#构造与析构顺序相反
构造顺序从上到下， 因为后面的变量可能依靠前面的变量
而析构顺序相反， 因为析构也有可能依赖这种关系析构
#对于构造过程
先完成每个属性的构造，在完成类的构造
析构与之相反
#类属性与方法
类属性与成员属性 性质功能
成员属性，每一个对象都有一份， 
##类方法与成员方法，主要区别在逻辑上的差别
成员方法：属于对象行为
类方法：非对象行为
类方法与成员方法区别类方法不能访问this指针， 成员方法可以访问this指针
##类属性跟成员属性区别：
功能上的区别：成员属性跟着对象走， 类属性全员只有一份，都可以访问到
##const方法
const修饰类型和方法，
const类型对象只能调用const类型方法

#c++中的结构体与类o
struct访问权限默认位public
class访问权限默认位private

#类型与变量
类型 = 类型数据 + 类型操作

#成员属性与方法
成员属性用来描述对象之间的差别的
类型描述逻辑的关系

#对象与引用

#为什么保留struct关键字
为了兼容c语言

#浅拷贝
两个不同的对象
默认的拷贝行为，
浅拷贝：会指向同一块内存区，解决大部分需求

#深拷贝
当data存储区的对象需要深拷贝时，(Memecpy)(Vector<Vector<int> ),无法做到深拷贝
用new运算符进行原地构造, 原地构造方式，某个地址上构造某个对象
# (T *)calloc(sizeof(T), n)这种方式，开辟空间

#对象的初始化
数据区：已经经过构造过的
对象表示已经初始化完成的数据区
完整的对象：就是经历了构造过程的数据存储区

#返回值优化

#函数重载
如果一个作用域内几个函数名字相同但是参数列表不同， 称位函数重载，与返回值没有关系

#函数重载的意义
1. 通过函数名对函数功能进行提示
2. 通过函数参数列表对函数的用法进行提示
3. 扩展已有的功能

#友元
若类外的一个函数想要访问类内部成员， 需要将函数声明为类的一个友元函数

#运算符重载
1. c++中重载能够扩展运算符的功能
2. 运算符重载以函数的方式进行
3. 用特殊形式的函数扩展运算符的功能
 Type operator Sign(type &obj1, type &obj2) {
    Type ret;
    //do something
    return ret;
}
Sign 是 +， -， * ，/等
单目运算符只有一个参数， 双目运算符有两个参数
 **

#数组对象
本质是个对象，特点是长得像数组
数组对象本质是重载[]

#函数对象
外在表现像函数的对象，实际是类+ 对象

所有函数对象类型不重要，外在表现重要

#函数指针对象
本质上是对象，外在表现是函数指针

#内存泄漏
动态的申请空间后，没有释放他们，内存消失不见

#智能指针
##环形引用
Z
